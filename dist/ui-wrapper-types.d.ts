// Generated by dts-bundle-generator v4.0.0

export interface IBuilder<T> {
	buildElement<P, S>(elementOption: ElementOption<T, P, S>): IElement<T>;
}
export interface ITagBuilder<T> extends IBuilder<T> {
	buildElement<P, S>(elementOption: TagElementOption<T, P, S>): IElement<T>;
}
export interface IFrameBuilder<T> extends IBuilder<T> {
	buildElement<P, S>(elementOption: FrameElementOption<T, P, S>): IElement<T>;
}
export interface IBuilderGetTagBuilderIn<T> {
	tagBuilderClass: new () => ITagBuilder<T>;
}
export interface IBuilderGetFrameBuilderIn<T> {
	frameBuilderClass: new () => IFrameBuilder<T>;
}
export interface Properties<T> {
	key?: string | number;
	children?: string | Array<string | T>;
}
export interface States {
}
export declare type PickState<S, K extends keyof S> = {
	[P in K]: S[P];
};
export interface IUnitLifeCycle {
	onBeforeProvide(): void;
	onAfterProvide(): void;
	onBeforeUpdate(): IUnitOnBeforeUpdateOut;
	onAfterUpdate(): void;
	onBeforeDispose(): void;
}
export interface IUnitBuilder<T> {
	getTagBuilder(): IUnitGetTagBuilderOut<T>;
	getFrameBuilder(): IUnitGetFrameBuilderOut<T>;
}
export interface IUnit<T, P, S> extends IUnitLifeCycle, IUnitBuilder<T> {
	provide(): IElement<T>;
	forceUpdate(): void;
	alterState<K extends keyof S>(param: IUnitAlterStateIn<S, K>): void;
	props: Readonly<P> & Readonly<Properties<T>>;
	state: Readonly<S>;
}
export interface IUnitAlterStateIn<S, K extends keyof S> {
	state: PickState<S, K>;
	callback?: () => void;
}
export interface IUnitOnBeforeUpdateOut {
	shouldUpdate: boolean;
}
export interface IElement<T> {
	element: T;
}
export interface IUnitSetPropsIn<P> {
	properties: P;
}
export interface IUnitGetTagBuilderOut<T> {
	tagBuilderClass: new () => ITagBuilder<T>;
}
export interface IUnitGetFrameBuilderOut<T> {
	frameBuilderClass: new () => IFrameBuilder<T>;
}
export interface ElementOption<T, P, S> {
	name: string | (new () => IUnit<T, P, S>);
	properties: P;
	children?: string | Array<string | T>;
}
export interface TagElementOption<T, P, S> extends ElementOption<T, P, S> {
	name: string;
}
export interface FrameElementOption<T, P, S> extends ElementOption<T, P, S> {
	name: new () => IUnit<T, P, S>;
}
export declare class Builder<T> {
	private builder;
	private static tagBuilderInstance;
	private static frameBuilderInstance;
	private constructor();
	static getTagBuilder<K>(param: IBuilderGetTagBuilderIn<K>): Builder<K>;
	static getFrameBuilder<K>(param: IBuilderGetFrameBuilderIn<K>): Builder<K>;
	buildElement<P, S>(elementOption: ElementOption<T, P, S>): IElement<T>;
}
export interface IPrimer<T> {
	start(param: PrimerStartOptions<T>): void;
}
export interface PrimerStartOptions<T> {
	element: T;
	target: HTMLElement;
}
export interface IPrimerEntry<T> {
	primer: new () => IPrimer<T>;
}
export interface PrimerElement<T> {
	element: T;
}
export interface PrimerTarget {
	target: HTMLElement;
}
export declare class Primer<T> {
	private entryPrimer;
	private element;
	private target;
	constructor(entry: IPrimerEntry<T>);
	getElement(): PrimerElement<T>;
	setElement(param: PrimerElement<T>): void;
	getTarget(): PrimerTarget;
	setTarget(param: PrimerTarget): void;
	start(): void;
}
export declare type TDemoElement = string;
export declare type TElement = TDemoElement;
declare abstract class UnitDemo<P, S> implements IUnit<TDemoElement, P, S> {
	private provided;
	protected constructor();
	state: Readonly<S>;
	props: Readonly<P>;
	onBeforeProvide(): void;
	onAfterProvide(): void;
	onBeforeUpdate(): IUnitOnBeforeUpdateOut;
	onAfterUpdate(): void;
	onBeforeDispose(): void;
	abstract provide(): IElement<TDemoElement>;
	forceUpdate(): void;
	alterState<K extends keyof S>(param: IUnitAlterStateIn<S, K>): void;
	getProvided(): IElement<TDemoElement>;
	onProvide(): void;
	onUpdate(): void;
	setProps(param: IUnitSetPropsIn<P>): void;
	getTagBuilder(): IUnitGetTagBuilderOut<TDemoElement>;
	getFrameBuilder(): IUnitGetFrameBuilderOut<TDemoElement>;
}
declare abstract class Unit<P, S> extends UnitDemo<P, S> {
}
export declare abstract class UnitFrame<P, S> extends Unit<P, S> {
	protected builder: IFrameBuilder<TElement>;
	constructor();
}
export declare abstract class UnitTag<P, S> extends Unit<P, S> {
	protected builder: ITagBuilder<TElement>;
	constructor();
}
export interface FoundElement {
	isFound: boolean;
	element: HTMLElement;
}
export interface IVirtualDocumentMakeElementOut {
	element: HTMLElement;
}
export interface IElementCollection {
	elementCollection: HTMLCollection;
}
export interface IDocument {
	doc: Document;
}
export interface IVirtualDocumentEntry {
	doc: Document;
}
export interface IElementId {
	id: string;
}
export interface MakeElementOption {
	tagName: string;
}
export interface IVirtualDocumentSetIdIn {
	id: string;
	source: HTMLElement;
}
export interface IVirtualDocumentAppendIn {
	source?: HTMLElement | Document;
	element: HTMLElement;
}
export interface IVirtualDocumentAppendStringIn {
	source: HTMLElement;
	text: string;
}
export interface IVirtualDocumentFindElementsByTagNameIn {
	source?: HTMLElement | Document;
	tagName: string;
}
export interface IVirtualDocumentSetAttributeIn {
	sourceElement: HTMLElement;
	attributeKey: string;
	attributeValue: string;
}
export interface IVirtualDocumentFindAttributeIn {
	sourceElement: HTMLElement;
	attributeKey: string;
}
export interface IVirtualDocumentFindAttributeOut {
	isFound: boolean;
	attributeValue: string;
}
export interface IVirtualDocumentFindFirstElementByQueryIn {
	query: string;
}
export interface IVirtualDocumentFindFirstElementByQueryOut {
	isFound: boolean;
	foundElement: Element;
}
export interface IVirtualDocumentReplaceElementsIn<T extends Element> {
	sourceElement: T;
	replaceableElement: T;
}
export declare class VirtualDocument {
	private doc;
	constructor(entry?: IVirtualDocumentEntry);
	createBase(): void;
	makeElement(param: MakeElementOption): IVirtualDocumentMakeElementOut;
	findElementById(param: IElementId): FoundElement;
	append(param: IVirtualDocumentAppendIn): void;
	appendString(param: IVirtualDocumentAppendStringIn): void;
	setId(param: IVirtualDocumentSetIdIn): void;
	replaceElements<T extends Element>(param: IVirtualDocumentReplaceElementsIn<T>): void;
	setAttribute(param: IVirtualDocumentSetAttributeIn): void;
	findAttribute(param: IVirtualDocumentFindAttributeIn): IVirtualDocumentFindAttributeOut;
	findParentElementByChildId(param: IElementId): FoundElement;
	findElementsByTagName(param: IVirtualDocumentFindElementsByTagNameIn): IElementCollection;
	findFirstElementByQuery(param: IVirtualDocumentFindFirstElementByQueryIn): IVirtualDocumentFindFirstElementByQueryOut;
	exportDocument(): IDocument;
	private checkStringLength;
}

export {};
